<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MRI-free TMS Targeting</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body { 
            padding: 15px; 
            background-color: #1e6091;
        }
        .main-container {
            max-width: 700px;
            margin: 0 auto;
        }
        h1 {
            font-size: 2rem;
            
        }
        .measurement-section, .form-container, .step3-container {
            border: 1px solid #e0e0e0;
            padding: 15px;  
            background-color: #ffffff;
            margin-bottom: 10px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .measurement-image {
            width: 100%;
            max-width: 900px;
            height: auto;
        }

        .measurement-container {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
        gap: 20px;
        }

        .measurement-input-section {
        flex: 1;
        min-width: 200px;
        }

        .measurement-image-section {
        flex: 1;
        text-align: center;
        }

        .measurement-figure {
        max-width: 100%;
        height: auto;
        max-height: 150px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .measurement-container {
                flex-direction: column;
                text-align: center;
            }
    
            .measurement-input-section {
            order: 2;
            margin-top: 10px;
            }
    
            .measurement-image-section {
            order: 1;
            }
    
            .measurement-figure {
            max-height: 120px;
            }
        }
        .references { 
            margin-top: 60px;
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-size: 0.8rem;

        }
        #target-coordinates { 
            display: none; 
        }
        #results-box { 
            display: none; 
            margin-top: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }
        #results-box .card-body {
            padding: 0;
        }

        #results-box .table {
            margin-bottom: 0; 
            font-size: 1.1rem
        }
        #results-box .table th {
            font-weight: 600;
            text-align: center;
            vertical-align: middle;
            padding: 15px 10px;
            border: none;
            border-bottom: none !important
        }
        #results-box .table td {
            text-align: center;
            vertical-align: middle;
            padding: 20px 15px;
            font-weight: 500;
            font-size: 1.2rem;
            color: #333;
            border-color: #dee2e6;
        }
        #results-box .table td:first-child {
            background-color: #f8f9fa;
        }
        #results-box .table td:last-child {
            background-color: #e3f2fd;
        }
        .result-image-cell {
            background-color: #ffffff !important;
            padding: 25px !important;
        }
        .result-image-cell img {
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            max-width: 100%;
            height: auto;
        }

        #viewer-3d {
            width: 100%;
            height: 600px;
            border: 2px solid #1e6091;
            border-radius: 8px;
            background-color: #111111;
            margin-top: 10px;
        }

        #viewer-error {
            display: none;
            color: #dc3545;
            margin-top: 10px;
            padding: 10px;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 5px;
        }

        #loading { 
            display: none; 
            margin-top: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }
        h2 {
            color: #495057;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 8px;
        }
        h3 {
            color: #495057;
            font-weight: 400;
            font-size: 0.8rem;
            padding-bottom: 5px;
        }

        h4 { 
            color: #495057;
            font-weight: 400;
            font-size: 1.2rem;
            padding-bottom: 5px;
        }

        .form-label {
            font-weight: 500;
            color: #495057;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .btn-primary {
            background-color: #1e6091;
            border-color: #0069a3;
            padding: 10px 20px;
            font-weight: 500;
        }
        .btn-primary:hover {
            background-color: #64B5F6;
            border-color: #0066cc;
        }
        .error-message {
            color: #dc3545;
            margin-top: 5px;
            font-size: 0.875em;
        }
        .measurement-input {
            width: 80px;
            display: inline-block;
            border: 2px solid #1e6091;
            border-radius: 6px
        }
        .step3-placeholder {
        color: #6c757d;
        font-style: italic;
        text-align: center;
        padding: 20px;
        background-color: #f8f9fa;
        border-radius: 8px;
        }
        
        .progress-container {
            width: 100%;
            background-color: #f3f3f3;
            border-radius: 5px;
            overflow: hidden;
            margin: 20px 0;
            display: none;
        }
        .progress-bar {
            width: 0;
            height: 20px;
            background-color: #4caf50;
            animation: progress 25s linear forwards;
        }
        @keyframes progress {
            from { width: 0; }
            to { width: 100%; }
        }
        .hidden {
            display: none;
        }

    </style>
</head>
<body>
    <div class="container main-container">
        <h1>Neuronavigation-free TMS Targeting</h1>        
        
        <form id="tms-form">
            <div class="measurement-section">
                <h4 class="section-title">Step 1: Enter Anatomical Measurements</h4>
                <!-- Nasion-Inion -->
                <div class="measurement-container">
                    <div class="measurement-input-section">
                        <label for="nasion_inion" class="form-label">Nasion-Inion Distance (cm):</label>
                        <input type="number" step="0.1" min="0"
                            class="form-control measurement-input"
                            id="nasion_inion" name="nasion_inion" required>
                        <div class="error-message" id="nasion_inion_error" style="display: none;"></div>
                    </div>
                    <div class="measurement-image-section">
                        <img src="/static/nasion-inion.jpg" alt="Nasion-Inion Distance Measurement" class="measurement-figure">
                    </div>
                </div>

                <!-- Tragus-Tragus -->
                <div class="measurement-container">
                    <div class="measurement-input-section">
                        <label for="tragus_tragus" class="form-label">Tragus-Tragus Distance (cm):</label>
                        <input type="number" step="0.1" min="0"
                            class="form-control measurement-input"
                            id="tragus_tragus" name="tragus_tragus" required>
                        <div class="error-message" id="tragus_tragus_error" style="display: none;"></div>
                    </div>
                    <div class="measurement-image-section">
                        <img src="/static/tragus_tragus.jpg" alt="Tragus-Tragus Distance Measurement" class="measurement-figure">
                    </div>
                </div>

                <!-- Head Circumference -->
                <div class="measurement-container">
                    <div class="measurement-input-section">
                        <label for="head_circ" class="form-label">Head Circumference (cm):</label>
                        <input type="number" step="0.1" min="0"
                            class="form-control measurement-input"
                            id="head_circ" name="head_circ" required>
                        <div class="error-message" id="head_circ_error" style="display: none;"></div>
                    </div>
                    <div class="measurement-image-section">
                        <img src="/static/head_circumference.jpg" alt="Head Circumference Measurement" class="measurement-figure">
                    </div>
                </div>
            </div>

            <div class="form-container">
                <div class="mb-3">
                    <h4 class="section-title">Step 2: Choose Targeting Method</h4>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="result_type" id="f3" value="f3" checked>
                        <label class="form-check-label" for="f3">Beam-F3*</label>
                    </div>
                    
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="result_type" id="valter" value="valter">
                        <label class="form-check-label" for="valter">Valter-MNI (head model creation takes about 20 sec)</label>
                    </div>
                </div>
                
                <div id="target-coordinates" class="mb-3">
                    <label class="form-label">TMS Target</label>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="target_choice" id="default" value="default" checked>
                        <label class="form-check-label" for="default">Default left DLPFC**</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="target_choice" id="custom" value="custom">
                        <label class="form-check-label" for="custom">Other (enter brain MNI coordinates)</label>
                    </div>
                    <div id="custom-coordinates" style="display: none;">
                        <div class="mb-3">
                            <label for="point_x" class="form-label">X Coordinate:</label>
                            <input type="number" step="0.1" class="form-control" id="point_x" name="point_x">
                        </div>
                        <div class="mb-3">
                            <label for="point_y" class="form-label">Y Coordinate:</label>
                            <input type="number" step="0.1" class="form-control" id="point_y" name="point_y">
                        </div>
                        <div class="mb-3">
                            <label for="point_z" class="form-label">Z Coordinate:</label>
                            <input type="number" step="0.1" class="form-control" id="point_z" name="point_z">
                        </div>
                    </div>
                </div>
                
                <div class="text-center">
                    <button type="submit" class="btn btn-primary">Submit</button>
                </div>
            </div>
        </form>
        
        <div class="step3-container">
            <h4 class="section-title">Step 3: Locate target using X and Y</h4>
            <div id="step3-placeholder" class="step3-placeholder">
                Submit your measurements above to generate targeting coordinates
            </div>
            <div id="progress-container" class="progress-container">
                <div class="progress-bar"></div>
            </div>
            <div id="results-box" class="card">
                <div class="card-body">
                    <table class="table table-bordered table-striped">
                        <thead class="table">
                            <tr>
                                <th scope="col" style="background-color: #819ce6; color: #000000;">X: Distance from midline around circumference (cm)</th>
                                <th scope="col" style="background-color: #7CFC00; color: #000000;">Y: Distance down from vertex (cm)</th>
                            </tr>
                        </thead>
                        <tbody id="results-table">
                        </tbody>
                    </table>
                    
                    <!-- 3D Viewer -->
                    <div id="viewer-container" style="display: none; padding: 20px;">
                        <div class="text-center mt-2" style="color: #6c757d; font-size: 0.9rem;">
                            Patient's 3D Head Model - Red dot indicates target location. Use mouse to rotate and zoom.
                        </div>
                        <div id="viewer-3d"></div>
                        <div id="viewer-error"></div>

                    </div>
                </div>
            </div>

            <div id="loading" class="alert alert-info" role="alert">
                <div class="d-flex align-items-center">
                    Processing... This may take some time
                </div>
            </div>
        </div>

        <div class="references">
            <h4>References and Notes</h4>           
            <p>Beam W, Borckardt JJ, Reeves ST, George MS. An efficient and accurate new method for locating the F3 position for prefrontal TMS applications. Brain Stimul. 2009 Jan;2(1):50-4. doi: 10.1016/j.brs.2008.09.006.</p>
            <p>Fox, M. D., Buckner, R. L., White, M. P., Greicius, M. D., & Pascual-Leone, A. (2012). Efficacy of transcranial magnetic stimulation targets for depression is related to intrinsic functional connectivity with the subgenual cingulate. Biological Psychiatry, 72(7), 595â€“603. https://doi.org/10.1016/j.biopsych.2012.04.028</p>
            <p>Li, Z., Sack, A. T., & Duecker, F. (2025). Finding F3: A comparative analysis of scalp-based methods for TMS coil positioning. Transcranial Magnetic Stimulation, 2, 100083.</p>
            <p>Mir-Moghtadaei A, Caballero R, Fried P, Fox MD, Lee K, Giacobbe P, Daskalakis ZJ, Blumberger DM, Downar J. Concordance Between BeamF3 and MRI-neuronavigated Target Sites for Repetitive Transcranial Magnetic Stimulation of the Left Dorsolateral Prefrontal Cortex. Brain Stimul. 2015 Sep-Oct;8(5):965-73. doi: 10.1016/j.brs.2015.05.008.</p>
            <p>Valter, Y., Truong, D. Q., Kawasumi, Y., Bikson, M., & Datta, A. (2025). TMS targeting using MRI-free head modeling. Transcranial Magnetic Stimulation, 5100188.</p>
            <p>*Implements the web-version of Beam-F3 including the adjustment of Mir-Moghtadaei et al. Code was obtained directly from the developers of the web Beam-F3 program.<p>
            <p>** MNI brain coordinates [-38, 44, 26] based on Fox et al.<p>
            <p>Developed by Yushi Kawasumi & Yishai Valter with research support from the NIMH and Soterix Medical<p>
            <p>Disclaimer: Information provided by this website is not medical advice.<p>
        </div>
    </div>

    <script>
        // Global variables for 3D viewer
        let scene, camera, renderer, mesh, brainMesh, targetMarker;
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let targetX = 0, targetY = 0;
        let cameraDistance = 150;

        // Initialize 3D viewer
        function init3DViewer() {
            const viewerElement = document.getElementById('viewer-3d');
            if (!viewerElement) return;

            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(60, viewerElement.clientWidth / viewerElement.clientHeight, 0.1, 1000);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewerElement.clientWidth, viewerElement.clientHeight);
            viewerElement.appendChild(renderer.domElement);

            // Add lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 75);
            scene.add(dirLight);

            // Mouse controls
            setupMouseControls(viewerElement);

            // Start animation loop
            animate();
        }

        function setupMouseControls(element) {
            element.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            element.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                targetX += deltaX * 0.01;
                targetY += deltaY * 0.01;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            element.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            element.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.1;
                cameraDistance = Math.max(50, Math.min(500, cameraDistance));
            });
        }

        function updateCamera() {
            if (!camera) return;
            camera.position.x = Math.sin(targetX) * cameraDistance;
            camera.position.z = Math.cos(targetX) * cameraDistance;
            camera.position.y = Math.sin(targetY) * cameraDistance;
            camera.lookAt(0, 0, 0);
        }

        function animate() {
            if (!renderer || !scene || !camera) return;
            requestAnimationFrame(animate);
            updateCamera();
            renderer.render(scene, camera);
        }

        // STL Loader
        function loadSTL(url, onLoad, onError) {
            const loader = new THREE.FileLoader();
            loader.setResponseType('arraybuffer');
            
            loader.load(url, function(data) {
                try {
                    const geometry = parseSTL(data);
                    onLoad(geometry);
                } catch (error) {
                    onError(error);
                }
            }, undefined, onError);
        }

        function parseSTL(data) {
            const geometry = new THREE.BufferGeometry();
            const dataView = new DataView(data);
            
            const triangleCount = dataView.getUint32(80, true);
            const vertices = [];
            const normals = [];
            
            let offset = 84;
            
            for (let i = 0; i < triangleCount; i++) {
                // Normal vector
                const nx = dataView.getFloat32(offset, true);
                const ny = dataView.getFloat32(offset + 4, true);
                const nz = dataView.getFloat32(offset + 8, true);
                offset += 12;
                
                // Three vertices
                for (let j = 0; j < 3; j++) {
                    const vx = dataView.getFloat32(offset, true);
                    const vy = dataView.getFloat32(offset + 4, true);
                    const vz = dataView.getFloat32(offset + 8, true);
                    
                    vertices.push(vx, vy, vz);
                    normals.push(nx, ny, nz);
                    
                    offset += 12;
                }
                
                offset += 2; // Skip attribute byte count
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            
            return geometry;
        }

        function load3DModel(targetPoint, timestamp, verticalPath, horizontalPath) {
            if (!scene) {
                init3DViewer();
            }

            const stlUrl = '/static/scaled_head.stl?' + timestamp;
            console.log('Loading STL from:', stlUrl);

            // Clear previous mesh and marker
            if (mesh) {
                scene.remove(mesh);
                mesh = null;
            }

            if (brainMesh) {
                scene.remove(brainMesh);
                brainMesh = null;
            }

            if (targetMarker) {
                scene.remove(targetMarker);
                targetMarker = null;
            }
            console.log('Target point from server:', targetPoint);
            loadSTL(stlUrl, function (geometry) {
                console.log('STL loaded successfully');
        
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xE0AC69, 
                    specular: 0x111111, 
                    shininess: 30, 
                    transparent: true,
                    opacity: 0.5

                });
                mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);

                // Center and scale the model
                geometry.computeBoundingBox();
                const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                const size = geometry.boundingBox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 100 / maxDim;
        
                mesh.position.sub(center);
                mesh.scale.set(scale, scale, scale);
                mesh.rotation.x = -Math.PI / 2;
                mesh.rotation.y = Math.PI / 16;

                // Load brain STL
                const brainStlUrl = '/static/scaled_brain.stl?' + timestamp;
                loadSTL(brainStlUrl, function (brainGeometry) {
                    console.log('Brain STL loaded successfully');
    
                    const brainMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x888888,
                        specular: 0x111111,
                        transparent: false,
                        opacity: 1.0, 
                        shininess: 30, 
                    });
                    brainMesh = new THREE.Mesh(brainGeometry, brainMaterial);
                    scene.add(brainMesh);

                    // Apply same transformations as head mesh (but don't center independently)
                    brainMesh.position.sub(center);  // Use the HEAD's center, not brain's center
                    brainMesh.scale.set(scale, scale, scale);
                    brainMesh.rotation.x = -Math.PI / 2;
                    brainMesh.rotation.y = Math.PI / 16;
                }, function(error) {
                    console.warn('Could not load brain STL:', error);
                    // Continue without brain model - this is optional
                });

                // Add target marker - FIXED POSITIONING
                console.log('Target point from server:', targetPoint);
        
                // Create the marker in world space first
                const sphereGeometry = new THREE.SphereGeometry(3, 32, 32);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                targetMarker = new THREE.Mesh(sphereGeometry, sphereMaterial);
        
                mesh.updateMatrixWorld();

                // Create a vector for our target point
                const adjustedTarget = new THREE.Vector3(
                    targetPoint[0],
                    targetPoint[1], 
                    targetPoint[2]
                );
                
                // Apply the head model's complete transformation matrix to the target point.
                // This single step correctly handles the scale, rotation, and translation in the proper order.
                adjustedTarget.applyMatrix4(mesh.matrixWorld);
        
                // Set the marker's final position
                targetMarker.position.copy(adjustedTarget);
                scene.add(targetMarker);
                console.log('Original target:', targetPoint);
                console.log('Mesh center:', center);
                console.log('Mesh scale:', scale);
                console.log('Final marker position:', adjustedTarget);

                function addPath(pathPoints, color) {
                    if (!pathPoints || pathPoints.length < 2) return;
                    const material = new THREE.LineBasicMaterial({ color: color, linewidth: 3 });
                    const transformedPoints = pathPoints.map(p => {
                        const v = new THREE.Vector3(p[0], p[1], p[2]);
                        return v.applyMatrix4(mesh.matrixWorld);
                    });
                    const geometry = new THREE.BufferGeometry().setFromPoints(transformedPoints);
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    return line;
                }

                console.log("Vertical path:", verticalPath);
                console.log("Horizontal path:", horizontalPath);
                var verticalLine = addPath(verticalPath, 0x00ff00);
                var horizontalLine = addPath(horizontalPath, 0x0000ff);
                
                // Reset camera
                cameraDistance = maxDim * 0.4;
                targetX = 0;
                targetY = 0;
                updateCamera();
        
                // Hide error message
                document.getElementById('viewer-error').style.display = 'none';
            
            });
        };

        $(document).ready(function() {
            // Clear any previous error messages
            function clearErrors() {
                $('.error-message').hide().text('');
                $('.form-control').removeClass('is-invalid');
            }
            
            // Show error message for a specific field
            function showError(fieldId, message) {
                $('#' + fieldId).addClass('is-invalid');
                $('#' + fieldId + '_error').text(message).show();
            }
            
            // Validate measurements
            function validateMeasurements() {
                clearErrors();
                let isValid = true;
                
                const headCirc = parseFloat($('#head_circ').val());
                const tragus = parseFloat($('#tragus_tragus').val());
                const nasion = parseFloat($('#nasion_inion').val());
                
                if (!headCirc || headCirc <= 0) {
                    showError('head_circ', 'Please enter a valid head circumference');
                    isValid = false;
                }
                
                if (!tragus || tragus <= 0) {
                    showError('tragus_tragus', 'Please enter a valid tragus-tragus distance');
                    isValid = false;
                }
                
                if (!nasion || nasion <= 0) {
                    showError('nasion_inion', 'Please enter a valid nasion-inion distance');
                    isValid = false;
                }
                
                // Basic sanity checks
                if (headCirc && (headCirc < 40 || headCirc > 70)) {
                    showError('head_circ', 'Head circumference seems unusual (typical range: 40-70 cm)');
                    isValid = false;
                }
                
                if (tragus && (tragus < 20 || tragus > 50)) {
                    showError('tragus_tragus', 'Tragus-tragus distance seems unusual (typical range: 20-50 cm)');
                    isValid = false;
                }
                
                if (nasion && (nasion < 20 || nasion > 45)) {
                    showError('nasion_inion', 'Nasion-inion distance seems unusual (typical range: 20-45 cm)');
                    isValid = false;
                }
                
                return isValid;
            }

            // Show/hide target coordinates based on result type
            $('input[name="result_type"]').change(function() {
                if ($('#valter').is(':checked')) {
                    $('#target-coordinates').show();
                } else {
                    $('#target-coordinates').hide();
                    $('#custom-coordinates').hide();
                    $('#point_x, #point_y, #point_z').prop('required', false);
                }
                $('#results-box').hide();
                $('#viewer-container').hide();
                $('#step3-placeholder').show();
                $('#progress-container').hide();
            });

            // Show/hide custom coordinate inputs when "Other" is selected
            $('input[name="target_choice"]').change(function() {
                if ($('#custom').is(':checked')) {
                    $('#custom-coordinates').show();
                    $('#point_x, #point_y, #point_z').prop('required', true);
                } else {
                    $('#custom-coordinates').hide();
                    $('#point_x, #point_y, #point_z').prop('required', false);
                }
            });

            // Handle form submission
            $('#tms-form').submit(function(event) {
                event.preventDefault();
                
                // Validate measurements first
                if (!validateMeasurements()) {
                    return false;
                }
                
                $('#step3-placeholder').hide();
                $('#loading').show();
                $('#results-box').hide();
                $('#progress-container').show();
                $('#viewer-container').hide();
                clearErrors();

                var formData = $(this).serialize();
                var resultType = $('input[name="result_type"]:checked').val();
                
                console.log('Submitting form data:', formData);
                console.log('Result type:', resultType);

                // Both methods now use AJAX
                $.ajax({
                    url: '/scale',
                    type: 'POST',
                    data: formData,
                    success: function(response) {
                        $('#loading').hide();
                        $('#progress-container').hide();
                        if (response.error) {
                            alert('Error: ' + response.error);
                            $('#step3-placeholder').show();
                            return;
                        }
                        
                        if (response.success) {
                            if (response.result_type === 'f3') {
                                // Beam-F3 results
                                $('#results-table').html(`
                                    <tr>
                                        <td style="background-color: #e3f2fd">${parseFloat(response.circumferential_dist).toFixed(1)}</td>
                                        <td style="background-color: #e6ffed">${parseFloat(response.vertex_dist_adjusted).toFixed(1)}</td>
                                    </tr>
                                    <tr>
                                        <td colspan="2" class="result-image-cell">
                                            <img src="/static/viewer_image.jpg" alt="Beam-F3 Result" class="img-fluid">
                                        </td>
                                    </tr>
                                `);
                                $('#viewer-container').hide();
                                $('#results-box').show();
                            } else if (response.result_type === 'valter') {                                
                                $('#results-table').html(`
                                    <tr>
                                        <td style="background-color: #e3f2fd">${parseFloat(response.circumferential_dist).toFixed(1)}</td>
                                        <td style="background-color: #e6ffed">${parseFloat(response.vertex_dist_adjusted).toFixed(1)}</td>
                                    </tr>
                                `);
                                
                                // Show 3D viewer
                                $('#viewer-container').show();
                                $('#results-box').show();
                                
                                // Initialize and load 3D model
                                setTimeout(() => {
                                    load3DModel(response.DLPFC_snapped, response.stl_timestamp, response.vertical_path, response.horizontal_path);
                                }, 100);
                            }
                        }
                    },
                    error: function(xhr, status, error) {
                        $('#loading').hide();
                        $('#step3-placeholder').show();
                        console.error('AJAX error:', error);
                        console.error('Response:', xhr.responseText);
                        let errorMessage = 'Unknown error occurred';
                        try {
                            const errorData = JSON.parse(xhr.responseText);
                            errorMessage = errorData.error || errorMessage;
                        } catch (e) {
                            errorMessage = xhr.responseText || errorMessage;
                        }
                        alert('Error: ' + errorMessage);
                    }
                });
            });

            // Handle window resize for 3D viewer
            $(window).resize(function() {
                if (renderer && camera) {
                    const viewerElement = document.getElementById('viewer-3d');
                    if (viewerElement) {
                        camera.aspect = viewerElement.clientWidth / viewerElement.clientHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(viewerElement.clientWidth, viewerElement.clientHeight);
                    }
                }
            });
        });
    </script>
</body>
</html>